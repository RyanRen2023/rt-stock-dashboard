package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"rpt-stock-dashboard/graphql-server/graph/model"
	"rpt-stock-dashboard/graphql-server/stock_client"
	"sync"
	"time"
)

// UpdateStockPrice is the resolver for the updateStockPrice field.
func (r *mutationResolver) UpdateStockPrice(ctx context.Context, stockCode string, price float64) (*model.Stock, error) {
	fmt.Printf("Updating stock %s price to $%.2f\n", stockCode, price)

	stock := &model.Stock{
		Symbol: stockCode,
		Price:  price,
	}
	r.Resolver.Subscription().(*subscriptionResolver).PublishStockPrice(stock)
	fmt.Printf("Notified all subscribers: %s - $%.2f\n", stock.Symbol, stock.Price)
	return stock, nil

}

// Stock is the resolver for the stock field.
func (r *queryResolver) Stock(ctx context.Context, stockCode string) (*model.Stock, error) {
	fmt.Printf("Fetching stock information: %s\n", stockCode)

	stock, err := stock_client.GetStockPrice(stockCode)
	if err != nil {
		fmt.Printf("Failed to fetch stock data: %v\n", err)
		return nil, err
	}
	fmt.Printf("Stock query successful: %s - $%.2f\n", stock.Symbol, stock.Price)
	return stock, err
}

// StockPriceUpdated is the resolver for the stockPriceUpdated field.

func (re *Resolver) StockPriceUpdated(ctx context.Context, stockCode string) (<-chan *model.Stock, error) {
	fmt.Printf("Subscription request: %s\n", stockCode)

	r := re.Subscription().(*subscriptionResolver)

	id := stockCode + "-" + time.Now().Format("150405")

	r.mu.Lock()
	defer r.mu.Unlock()

	// Ensure `observers` is properly initialized
	if r.observers == nil {
		r.observers = make(map[string]map[string]chan *model.Stock)
	}

	// Ensure `observers[stockCode]` is properly initialized
	if _, ok := r.observers[stockCode]; !ok {
		r.observers[stockCode] = make(map[string]chan *model.Stock)
	}

	// Ensure `observers` correctly stores `stockCode`
	ch := make(chan *model.Stock, 1)
	r.observers[stockCode][id] = ch

	fmt.Printf("Subscription successful: %s (ID: %s)\n", stockCode, id)
	fmt.Printf("Observers data structure after subscription: %+v\n", r.observers)

	// Monitor cancellation event and clean up automatically
	go func() {
		<-ctx.Done()
		r.mu.Lock()
		delete(r.observers[stockCode], id)
		close(ch)
		r.mu.Unlock()
		fmt.Printf("Subscription canceled: %s (ID: %s)\n", stockCode, id)
	}()

	return ch, nil
}

func (r *subscriptionResolver) PublishStockPrice(stock *model.Stock) {
	r.mu.Lock()
	defer r.mu.Unlock()
	fmt.Printf("Calling PublishStockPrice() %v", stock)

	if observers, ok := r.observers[stock.Symbol]; ok {
		fmt.Printf("Pushing data to %d subscribers: %s - $%.2f\n", len(observers), stock.Symbol, stock.Price)

		for _, observer := range observers {
			observer <- stock
		}
	} else {
		fmt.Printf("No subscribers: %s - $%.2f\n", stock.Symbol, stock.Price)

	}
}

func (r *Resolver) PublishStockPrice(stock *model.Stock) {
	fmt.Printf("Calling PublishStockPrice() -> %s - $%.2f\n", stock.Symbol, stock.Price)
	// Use `r.Subscription()` to get the same subscriptionResolver
	r.Subscription().(*subscriptionResolver).PublishStockPrice(stock)
}

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Observers() []string {
	subResolver := r.Subscription().(*subscriptionResolver)

	subResolver.mu.Lock()
	defer subResolver.mu.Unlock()

	// Print `observers` data structure for debugging
	fmt.Printf("Debug: observers data structure: %+v\n", subResolver.observers)

	// Collect all subscribed stock codes
	stockSet := make(map[string]bool)
	for stockCode, subscribers := range subResolver.observers {
		if len(subscribers) > 0 {
			stockSet[stockCode] = true
		}
	}

	// Convert to string slice
	var stockCodes []string
	for stockCode := range stockSet {
		stockCodes = append(stockCodes, stockCode)
	}

	fmt.Printf("Currently subscribed stock codes: %v\n", stockCodes)
	return stockCodes
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver {
	r.once.Do(func() { // Ensure initialization only once
		fmt.Println("Initializing subscriptionResolver...")
		r.subscription = &subscriptionResolver{
			Resolver:  r,
			mu:        sync.Mutex{}, // Use a pointer to prevent `sync.Mutex` from being copied
			observers: make(map[string]map[string]chan *model.Stock),
		}
	})
	return r.subscription

}

type subscriptionResolver struct {
	*Resolver
	mu        sync.Mutex
	observers map[string]map[string]chan *model.Stock
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
