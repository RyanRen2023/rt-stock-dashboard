# **CST 8916 Assignment 1: Designing a Real-time Stock Market Monitoring Application with REST, GraphQL, and WebSockets**

## Introduction**
This project focuses on designing and developing a real-time stock market monitoring application that integrates REST APIs, GraphQL, and WebSockets to provide realtime stock market data. The system enables users to search for stocks and subscribe to real-time updates. The backend utilizes a RESTful API for stock data retrieval, GraphQL for filter queries, and WebSockets for live updates. The frontend is built with React and Ant Design, offering an interactive and user-friendly experience.

## Section 1: REST and GraphQL for Data Requests and Updates
> **Explain** how both REST and GraphQL could be used to handle the data requests and updates required by the system.
  >> For REST, describe how different endpoints could be structured, and how reqåuests such as `GET`, `POST`, `PUT`, and `DELETE` would manage data.
  >> For GraphQL, describe how queries and mutations could handle the same data operations and how this approach differs from REST
>
> **Compare** the pros and cons of using REST versus GraphQL for your specific use case.

### **1.1 How REST and GraphQL Handle Data Requests and Updates**
#### **REST API**


A **REST API** is an abbreviation of the "Representational State Transfer Application Programming Interface". It conforms to the design principles of the 
Representational State Transfer (REST) architectural style. REST APIs provide a flexible and lightweight way to access application resources. (IBM, 2021)


- REST APIs communicate through HTTP requests.There are nine HTTP methods associated with REST APIs.(McKenzie, 2023)
  
   - GET： Used to retrieve data from server. 
   - POST. Used to send data to the server for processing
   - DELETE. Used to remove data from server
   - PUT.  Used to update data from server
   - PATCH. Used to partially update data from server
   - HEAD: Used to retrieve metadata about a resource on the server
   - OPTIONS: Used to retrieve a listing of which HTTP methods are supported and allowed.
   - TRACE : Used to retrieve a diagnostic trace that logs data from the request-response cycle.
   - CONNECT. Used to create a connection with a server-side resource.

#### **GraphQL**


GraphQL is a **query language for APIs**. It is also a runtime for executing queries. With GraphQL, you have the ability to specify the data you want, making data fetching more efficient.(The GraphQL Foundation, 2012)


GraphQL supports three main operation types: queries, mutations, and subscriptions. (The GraphQL Foundation, n.d.)
-  **Queries** are used to retrieve data. The same as the GET request in REST API
-  **Mutations** are used to modify data, Including add,update and delete. Similar to POST, PUT,PATCH, and DELETE in REST API.
-  **Subscriptions** – Enable real-time communication using **WebSockets**

### **1.2 Comparison: REST vs. GraphQL**(Nefe Emadamerho-Atori, 2024)

| **Compare Items**         | **GraphQL**                          | **REST API**                                  |
|---------------------------|-------------------------------------|----------------------------------------------|
| **Endpoints**             | Single endpoint for all operations | Multiple endpoints                          |
| **Type System**           | Strongly typed                     | Not strongly typed                          |
| **API Versioning**        | No versioning required             | Requires versioning                         |
| **Error Handling**        | In the errors field                | By HTTP status codes                        |
| **Data Fetching Efficiency** | Fetches only the requested data    | Fixed endpoints return full resource data   |
| **Caching Strategies**    | More complex, relies on client     | Simple, using standard HTTP caching mechanisms |
| **File Uploads**          | Complex, requires additional setup | Simple, natively supports                   |
| **Real-Time Capabilities** | Via subscriptions                 | Via polling, long polling, server-sent events |
### 1.3 Code Examples(Generated by ChatGPT)

#### **1.3.1 Fetch data**

**REST API (Fetching a User)** 

```http

  # http GET request
  GET /users/1
  
```

Response:

```json
  // response from server
  {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
  }
```
**GraphQL Query (Fetching a User)**

```graphQL  

  # query from client
  query {
    user(id: 1) {
      name
      email
    }
  }


```
Response:
```json
// response from server
{
  "data": {
    "user": {
      "name": "Alice",
      "email": "alice@example.com"
    }
  }
}

```

#### **1.3.2 Mutate data**

**REST API**

```http
# create user（REST API）
  POST /users
  Content-Type: application/json

  {
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
  }

```
Response

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com"
}

```
**graphQL**

```graphql
# create user
    mutation {
        createUser(name: "Alice", email: "alice@example.com", age: 30) {
          id
          name
          email
        }
    }

```
Response

```json
// response data from server
{
  "data": {
    "createUser": {
      "id": 1,
      "name": "Alice",
      "email": "alice@example.com"
    }
  }
}

```
### **1.4 Real-Time Stock Monitoring: REST vs. GraphQL**

In our use case the **Real-time Stock Market Monitoring Application** , there are two main scenarios, one is querying stock information, and the other is subscribing to stocks. In the first scenario, it is a regular query request that fetches stock data from the server. In the second scenario, after subscribing to a stock from the server, the stock information is updated in real-time. 

Here is the comparison of the Pros & Cons in our User Case


<table>
  <tr>
      <th>Feature</th>
      <th>REST API</th>
      <th>GraphQL API</th>
  </tr>
  <tr>
      <td>API Wrapping</td>
      <td>Idea for retrieving raw stock data and providing full-service access,not only for client but also for storage and anlysis.</td>
      <td>Idea for custom filed selection based on specific requirements</td>
  </tr>
  <tr>
      <td rowspan="3">Data Fetching</td>
      <td>Fixed endpoints return full resources.</td>
      <td>Clients define the exact fields they need.</td>
  </tr>
  <tr>
      <td>Needs multiple endpoints to fetch different data</td>
      <td>A single query fetches multiple related fields.</td>
  </tr>
    <tr>
      <td>Cannot tailor response data,which may return too much or too little data.</td>
      <td>Flexible querying allows fetching only the needed data.</td>
  </tr>
    <tr>
      <td>Server Implementation</td>
      <td>Each resource needs a separate endpoint</td>
      <td>A single endpoint (/graphql) handles multiple resources dynamically.</td>
  </tr>
    <tr>
      <td>Client Implementation</td>
      <td>Each request must target a specific endpoint for different resources.</td>
      <td>The client uses one endpoint with parameters to implement multipe operations.</td>
  </tr>
  <tr>
      <td>Real-time Implementation</td>
      <td>Requires polling or WebSockets</td>
      <td>Built-in subscriptions enable real-time updates efficiently via WebSockets.</td>
  </tr>
</table>



## Section 2: WebSockets for Real-time Communication
- **Describe** how WebSockets could be used to handle real-time communication in your chosen system.


- **Discuss** how WebSockets differ from REST and GraphQL in managing real-time data flow.

## Section 3: Technology Recommendation and Justification
- **Recommend** which technology (or combination of technologies) you would choose for your system: REST, GraphQL, WebSockets, or a hybrid approach.
    - Justify your recommendation based on your analysis in Sections 1 and 2.
    - Consider factors such as data complexity, real-time requirements, scalability, and ease of use for developers.

- **Explain** why this combination is best suited for your use case in terms of performance, scalability, and real-time capabilities.



## References**
- Official documentation for REST, GraphQL, and WebSockets
- Stock market APIs and data sources
- Other relevant sources
