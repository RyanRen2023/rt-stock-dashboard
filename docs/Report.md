# **CST 8916 Assignment 1: Designing a Real-time Stock Market Monitoring Application with REST, GraphQL, and WebSockets**

## Introduction

This project focuses on designing and developing a real-time stock market monitoring application that integrates REST APIs, GraphQL, and WebSockets to provide realtime stock market data. The system enables users to search for stocks and subscribe to real-time updates. The backend utilizes a RESTful API for stock data retrieval, GraphQL for filter queries, and WebSockets for live updates. The frontend is built with React and Ant Design, offering an interactive and user-friendly experience.

## Section 1: REST and GraphQL for Data Requests and Updates
> **Explain** how both REST and GraphQL could be used to handle the data requests and updates required by the system.
  >> For REST, describe how different endpoints could be structured, and how reqåuests such as `GET`, `POST`, `PUT`, and `DELETE` would manage data.
  >> For GraphQL, describe how queries and mutations could handle the same data operations and how this approach differs from REST
>
> **Compare** the pros and cons of using REST versus GraphQL for your specific use case.

### **1.1 How REST and GraphQL Handle Data Requests and Updates**
#### **REST API**


A **REST API** is an abbreviation of the "Representational State Transfer Application Programming Interface". It conforms to the design principles of the 
Representational State Transfer (REST) architectural style. REST APIs provide a flexible and lightweight way to access application resources. (IBM, 2021)


- REST APIs communicate through HTTP requests.There are nine HTTP methods associated with REST APIs.(McKenzie, 2023)
  
   - GET： Used to retrieve data from server. 
   - POST. Used to send data to the server for processing
   - DELETE. Used to remove data from server
   - PUT.  Used to update data from server
   - PATCH. Used to partially update data from server
   - HEAD: Used to retrieve metadata about a resource on the server
   - OPTIONS: Used to retrieve a listing of which HTTP methods are supported and allowed.
   - TRACE : Used to retrieve a diagnostic trace that logs data from the request-response cycle.
   - CONNECT. Used to create a connection with a server-side resource.

#### **GraphQL**


GraphQL is a **query language for APIs**. It is also a runtime for executing queries. With GraphQL, you have the ability to specify the data you want, making data fetching more efficient.(The GraphQL Foundation, 2012)


GraphQL supports three main operation types: queries, mutations, and subscriptions. (The GraphQL Foundation, n.d.)
-  **Queries** are used to retrieve data. The same as the GET request in REST API
-  **Mutations** are used to modify data, Including add,update and delete. Similar to POST, PUT,PATCH, and DELETE in REST API.
-  **Subscriptions** – Enable real-time communication using **WebSockets**

### **1.2 Comparison: REST vs. GraphQL**(Nefe Emadamerho-Atori, 2024)

| **Compare Items**         | **GraphQL**                          | **REST API**                                  |
|---------------------------|-------------------------------------|----------------------------------------------|
| **Endpoints**             | Single endpoint for all operations | Multiple endpoints                          |
| **Type System**           | Strongly typed                     | Not strongly typed                          |
| **API Versioning**        | No versioning required             | Requires versioning                         |
| **Error Handling**        | In the errors field                | By HTTP status codes                        |
| **Data Fetching Efficiency** | Fetches only the requested data    | Fixed endpoints return full resource data   |
| **Caching Strategies**    | More complex, relies on client     | Simple, using standard HTTP caching mechanisms |
| **File Uploads**          | Complex, requires additional setup | Simple, natively supports                   |
| **Real-Time Capabilities** | Via subscriptions                 | Via polling, long polling, server-sent events |
### 1.3 Code Examples(Generated by ChatGPT)

#### **1.3.1 Fetch data**

**REST API (Fetching a User)** 

```http

  # http GET request
  GET /users/1
  
```

Response:

```json
  // response from server
  {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
  }
```
**GraphQL Query (Fetching a User)**

```graphQL  

  # query from client
  query {
    user(id: 1) {
      name
      email
    }
  }


```
Response:
```json
// response from server
{
  "data": {
    "user": {
      "name": "Alice",
      "email": "alice@example.com"
    }
  }
}

```

#### **1.3.2 Mutate data**

**REST API**

```http
# create user（REST API）
  POST /users
  Content-Type: application/json

  {
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
  }

```
Response

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com"
}

```
**graphQL**

```graphql
# create user
    mutation {
        createUser(name: "Alice", email: "alice@example.com", age: 30) {
          id
          name
          email
        }
    }

```
Response

```json
// response data from server
{
  "data": {
    "createUser": {
      "id": 1,
      "name": "Alice",
      "email": "alice@example.com"
    }
  }
}

```
### **1.4 Real-Time Stock Monitoring: REST vs. GraphQL**

In our use case the **Real-time Stock Market Monitoring Application** , there are two main scenarios, one is querying stock information, and the other is subscribing to stocks. In the first scenario, it is a regular query request that fetches stock data from the server. In the second scenario, after subscribing to a stock from the server, the stock information is updated in real-time. 

Here is the comparison of the Pros & Cons in our User Case


<table>
  <tr>
      <th>Feature</th>
      <th>REST API</th>
      <th>GraphQL API</th>
  </tr>
  <tr>
      <td>API Wrapping</td>
      <td>Idea for retrieving raw stock data and providing full-service access,not only for client but also for storage and anlysis.</td>
      <td>Idea for custom filed selection based on specific requirements</td>
  </tr>
  <tr>
      <td rowspan="3">Data Fetching</td>
      <td>Fixed endpoints return full resources.</td>
      <td>Clients define the exact fields they need.</td>
  </tr>
  <tr>
      <td>Needs multiple endpoints to fetch different data</td>
      <td>A single query fetches multiple related fields.</td>
  </tr>
    <tr>
      <td>Cannot tailor response data,which may return too much or too little data.</td>
      <td>Flexible querying allows fetching only the needed data.</td>
  </tr>
    <tr>
      <td>Server Implementation</td>
      <td>Each resource needs a separate endpoint</td>
      <td>A single endpoint (/graphql) handles multiple resources dynamically.</td>
  </tr>
    <tr>
      <td>Client Implementation</td>
      <td>Each request must target a specific endpoint for different resources.</td>
      <td>The client uses one endpoint with parameters to implement multipe operations.</td>
  </tr>
  <tr>
      <td>Real-time Implementation</td>
      <td>Requires polling or WebSockets</td>
      <td>Built-in subscriptions enable real-time updates efficiently via WebSockets.</td>
  </tr>
</table>



## Section 2: WebSockets for Real-time Communication

>  **Describe** how WebSockets could be used to handle real-time communication in your chosen system.
> 
> **Discuss** how WebSockets differ from REST and GraphQL in managing real-time data flow.

### **2.1 How WebSockets Work in This System**


A WebSocket is a persistent, two-way(full-duplex) TCP connection between the server and the client. Once the connection is established, both the client and the server can communicate with each other without requiring additional requests.(frontend.turing.edu, n.d.)

Taking advantage of this feature, we can build a real-time stock monitoring application to track stock prices. When detecting a stock price update, the server can immediately push the updated data to all connected clients without delay. 

Here is the workflow that used in our application:

![WebSockets Workflow](./diagrams/docs/diagrams/Subscription%20Workflow%20-%20Real-time%20Stock%20Updates.png)

1. User clicks the subscription button. (The frontend adds the selected stock to the list of subscribed stocks.)
2. Frontend sends a subsription request to the GraphQL Server.(This request is handled by Apollo Client, which opens a WebSocket connection to listen for price updates.)
3. GraphQL Server confirms the subscription request and establishes a Websocket connection.(The server ensures that the client is now subscribed to receive real-time updates for the selected stock.)
4. GraphQL Server creates a background thread to monitor stock price updates.( A Goroutine (Go background thread) is created for each subscribed stock. • The server fetches the latest stock price from an external API instead of monitoring an internal database.)
5. The background thread monitors stock price update and sends new stock prices to the Websocket connection
6. WebSocket connection sends the stock price update to frontend

In this project, we use GraphQL Subscriptions over WebSockets to keep stock prices updated in real-time. Instead of constantly asking the server for new data (which would slow things down and put unnecessary load on the system), WebSockets allow the server to push updates automatically whenever stock prices change. This makes everything feel instant and responsive.




### **2.2 The comparison of managing real-time data flow**(Das, 2024)


<table>
  <tr>
    <th>WebSocket</th>
    <th>REST</th>
    <th>GraphQL</th>
  </tr>
  <tr>
    <td> 
      <ul>
        <li>Over TCP</li>
        <li>Persistent connection</li>
        <li>Full-duplex (bi-directional)</li>
        <li>Event-driven</li>
        <li>Low latency</li>
      </ul>
    </td>
    <td>
      <ul>
        <li>Over HTTP</li>
        <li>Stateless</li>
        <li>Polling, long polling, or server-sent events (SSE)(Martin, 2024)</li>
        <li>One-way connection</li>
        <li>High overhead</li>
      </ul>
    </td>
    <td>
      <ul>
        <li><strong>Implemented over WebSockets</strong></li>
        <li>subscriptions maintain an active connection</li>
        <li>Flexible Queries</li>
      </ul>
    </td>
  </tr>
</table>

### **2.3 Why Use WebSockets Instead of REST or GraphQL Queries？**

| Feature               | REST API | GraphQL Query | WebSockets (GraphQL Subscriptions) |
|-----------------------|---------|--------------|----------------------------------|
| **Mechanism**        | Sends a new request each time data is needed | Allows the client to request only the needed data | Keeps a persistent connection open and pushes updates automatically |
| **Speed**            | Slower – requires multiple requests for updates | Medium – avoids over-fetching but still needs polling for updates | Fastest – updates sent instantly without repeated requests |
| **Server Load**      | High – every request initiates a new connection | Low – reduces redundant data transfer | Low – reduces frequent API calls |
| **Best For**        | Static data requests where real-time updates are not required | Flexible data fetching when updates aren’t needed in real-time | Real-time updates where instant data changes matter (e.g., stock price tracking) |


For our system, we use REST API for fetching stock details, GraphQL Queries for flexible filtering, and WebSockets for live updates. This combination ensures the best mix of efficiency, scalability, and real-time performance.

### **2.4 The Good and the Bad of WebSockets**

| **Pros of WebSockets** | **Cons of WebSockets** |
|------------------------|------------------------|
| **Instant updates** – No waiting around for new stock prices. | **Too many connections** – Each subscribed stock creates a WebSocket connection, which could be a problem if there are too many. |
| **Fewer requests** – Saves bandwidth and reduces server load. | **Scalability issues** – If lots of people subscribe to different stocks, the server has to work harder. |
| **Better experience** – Feels smooth and real-time. | **Connection drops** – If a WebSocket disconnects, we need to reconnect it properly. |


## Section 3: Technology Recommendation and Justification

> **Recommend** which technology (or combination of technologies) you would choose for your system: REST, GraphQL, WebSockets, or a hybrid approach.
> 
>> - Justify your recommendation based on your analysis in Sections 1 and 2.
>> - Consider factors such as data complexity, real-time requirements, scalability, and ease of use for developers
>
>**Explain** why this combination is best suited for your use case in terms of performance, scalability, and real-time capabilities.

### **3.1 Recommended Approach**

After carefully analyzing the system’s needs, we recommend a hybrid approach to build our real-time stock market monitoring application. This approach balances performance, scalability, and real-time responsiveness by leveraging the strengths of multiple technologies:

- REST API for retrieving raw stock data from external sources and standardizing it.
- GraphQL Queries for flexible client-side queries, enabling users to request only the data they need.
- GraphQL Subscription (WebSockets)  for real-time stock price updates with low latency.

### **3.2 Justification**
| Factor | REST API | GraphQL Queries | GraphQL Subscription |
|--------|---------|---------|-----------|
| **API Wrapping** | Encapsulates third-party APIs <br> Standardizes data format <br> Supports caching | --- | --- |
| **Real-time Support** | --- | ---| Best for real-time updates <br> Low-latency push via WebSockets|
| **Ease of Use** | Simple and Widely supported | Flexible Queries | --- |

### **3.3 Why This Combination Works Best**

- **REST API** is a solid choice for fetching raw stock data—it’s simple, widely used, and reliable.

- **GraphQL Queries** help optimize data requests by letting us pull only what we actually need, avoiding unnecessary load on the system.

- **GraphQL Subscriptions (WebSockets)** allow for real-time stock price updates, so users always see the latest data instantly without constantly refreshing.

### **3.4 Performance, Scalability, and Real-Time Capabilities**

**Performance Optimization**

- GraphQL helps reduce unnecessary data transfer, making the system more efficient.
- WebSockets remove the need for polling, cutting down on redundant API calls and keeping the server load light.
- REST API benefits from caching, making repeated requests faster and less demanding on resources.
  
**Scalability Considerations**

- Managing WebSocket connections effectively:
  
  - Right now, each stock subscription creates a separate WebSocket connection, which isn’t ideal at scale.
  - To fix this, we can introduce batch stock subscriptions, so multiple stocks can be handled under a single connection, reducing overhead.

**Load balancing for stability**

- Spread out WebSocket traffic across multiple servers to keep performance smooth.

- Use Redis caching to store frequently accessed stock data, minimizing unnecessary API calls.

**Real-Time Capabilities**

- WebSockets push stock updates instantly, so users always have the most up-to-date information.

- Auto-reconnect features ensure stability, even if the connection drops momentarily.

- If WebSockets are unavailable, periodic API polling will serve as a fallback to maintain functionality.


### **3.4 Conclusion**
By combining **REST API, GraphQL Queries, and GraphQL Subscription**, we achieve an efficient, scalable, and real-time stock monitoring system. 
- The **REST API** encapsulates third-party stock APIs, provides a standardized data format, and enables caching mechanisms.
- **GraphQL Queries** provid flexible and efficient data queries.
- **GraphQL Subscription** leverage WebSockets for real-time stock price updates.



## References
- **Documentation for REST, GraphQL, and WebSockets**
  - Das, A. (2024, August 17). _How to Use GraphQL Subscriptions for Real-Time Data_. PixelFreeStudio Blog -. https://blog.pixelfreestudio.com/how-to-use-graphql-subscriptions-for-real-time-data/
  - frontend.turing.edu. (n.d.). _Building Real-Time Applications with WebSockets_. frontend.turing.edu. https://frontend.turing.edu/lessons/module-4/websockets.html?ads_cmpid=6451354298&ads_adid=76255849919&ads_matchtype=&ads_network=g&ads_creative=582477081488&utm_term=&ads_targetid=dsa-19959388920&utm_campaign=&utm_source=adwords&utm_medium=ppc&ttv=2&gad_source=1&gclid=CjwKCAiAw5W-BhAhEiwApv4goN3PggXW-GUOlm5BggyMUD_eRxRxjKTKrSjkcWqgV-myPKB7FY3iVxoCxMMQAvD_BwE
  - IBM. “REST APIs.” _Ibm.com_, 19 Oct. 2021, www.ibm.com/think/topics/rest-apis. Accessed 5 Mar. 2025.
  - Martin, E. (2024, September 26). _WebSockets vs Server-Sent Events: Key differences and which to use in 2024_. Ably Realtime. https://ably.com/blog/websockets-vs-sse
  - McKenzie, C. (2023, August 21). _HTTP request methods explained_. Www.theserverside.com. https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/HTTP-methods
  - Nefe Emadamerho-Atori. (2024, September 20). _GraphQL vs. REST: API Guide - Benefits, Pros & Cons, & More_. Prismic. https://prismic.io/blog/graphql-vs-rest-api?account_id=4897815674&campaign_id=22180677541&group_id=&ad_id=&placement=&keyword_id=&network=x&matchtype=&utm_device=c&utm_term=&utm_campaign=RoW_en_PMax_BOFU&utm_source=adwords&utm_medium=ppc&utm_content=&hsa_acc=4897815674&hsa_cam=22180677541&hsa_grp=&hsa_ad=&hsa_src=x&hsa_tgt=&hsa_kw=&hsa_mt=&hsa_net=adwords&hsa_ver=3&gad_source=1&gclid=CjwKCAiAw5W-BhAhEiwApv4goP9RtZdk_zqwMSUJDVRunlptTgM6WOFCRy7MeeGA3m7dumGku5mqtxoCCO4QAvD_BwE
  - The GraphQL Foundation. (n.d.). _Queries and Mutations_ | GraphQL. Graphql.org. https://graphql.org/learn/queries/
  - The GraphQL Foundation. (2012). _GraphQL: A query language for APIs_. Graphql.org. https://graphql.org/

- **Stock market APIs and data sources**
  - https://query1.finance.yahoo.com/v8/finance/chart/%s (%s stock code) 
